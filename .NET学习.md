### 数组声明

* 数组声明用new关键字
* 在声明数组时，可以使用{}来初始化数组中的元素
* 如果在数组声明之初没有使用大括号来初始化数组中的元素，则需要指定数组的大小
* 在声明初始化有有元素的数组时，也可以指定数组大小

``` c#
//声明没有元素的数组
int[] ints = new int[6]
//声明初始化有元素的数组时，也可以指定数组大小
int[] ints = new int[]{1, 2, 3, 4, 5}
//在声明初始化有元素的数组时，也可以指定数组大小
string[] strings = new int[5]{"H", "E", "L", "L", "O"}

int l = ints.Length;  //获取数组的长度
```

```c#
//初始化数组
//标准写法 驼峰命名
string[] classStudents = new string[]{"张三","李四","王五","赵六","田七","周八"};
//简便写法
string[] classStudents = {"张三","李四","王五","赵六","田七","周八"};
```



### 类型转换

* (int)表示使用显式强制转换，不遵循四舍五入，只截取整数部分；

* (int)5.21  //输出5

* Int.Parse()：只支持string类型转成int，Parse就是把String类型转换成int、char、double...等，也就是Int.Parse(string)括号中的一定要是string类型。

```c#
String st = "5.21";
double n = 5.21;
Int.Parse(st);  //输出5
Int.Parse(n);  //报错
```

* Convert.ToInt32(double value)，不完全遵循四舍五入，如果value为两个整数中间的数字，则返回二者中的偶数，例子如下：

``` c#
Console.WriteLine(Convert.ToInt(4.3));  //四舍五入，输出4
Console.WriteLine(Convert.ToInt(4.5));  //第一位小数为5时，4.5在4和5之间，输出偶数4
Console.WriteLine(Convert.ToInt(4.53));  //四舍五入，输出5
```

```c#
Console.WriteLine(Convert.ToInt(5.3));  //四舍五入，输出5
Console.WriteLine(Convert.ToInt(5.5));  //第一位小数为5时，5.5在5和6之间，输出偶数6
Console.WriteLine(Convert.ToInt(5.53));  //四舍五入，输出6
```

* **注意：**Convert.ToInt32()和int.Parse()对于空值(null)的处理不同，Convert.ToInt32(null)会返回0而不会产生任何异常，但int.Parse(null)则会产生异常



### 字符串拼接

![image-20220609154508140](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220609154508140.png)



### out和ref的区别

* *out* 修饰的参数**必须在方法内修改**，而 *ref* **可以修改也可以不修改**；
* *out* 在传入参数的时候，参数是局部变量的话，可以不用赋值，因为 *out* 一定会对其进行赋值；
* 而 *ref* 修饰的参数，在实参**必须有初值时才能调用**。因为 *ref* 修饰的不一定会给它赋值。



### 实例化

```c#
//实例化后，通过对象调用属性
Person zhangsan = new Person();
zhangsan.Name = "张三";
zhangsan.Age = 18;
zhangsan.Height = 175;
zhangsan.Eat();
zhangsan.Run();
```



```c#
//实例化当中给对象赋值
Person zhangsan = new Person()
{
	Age = 18,
	Height = 170,
	Name = "张三"
};
```



### 访问修饰符

public：公有的 所有的类都可以访问

private：私有的 当前类内部可访问

protected：受保护的 当前类以及继承他的子类可以访问

internal：内部的 只限于本项目内访问，其他的不能访问

protected internal：内部保护访问 只能是本项目内部或子类访问 其他类不能访问

**注意：**类的访问级别默认为 *隐式私有* 需要加上 *public* 才可让外部访问



##### 静态方法、属性

* 静态和属性方法通过 *static* 关键字修饰
* 静态和属性可以通过类型直接获取，非静态则必须通过实例化的对象获取
* 静态方法中只能使用静态字段

##### 静态类

* 静态类通过 *static* 关键字修饰
* 一般情况下类型不需要使用静态修饰，只有当类型中存在扩展方法时需要使用**静态类**



### 集合&字典的初识

###### ArrayList的优势

* ArrayList 的大小是按照其中存储的数据来动态扩充与收缩的

* 在声明 ArrayList 对象时，并不需要指定它的长度

* ArrayList 可以很方便的进行数据的添加，插入和移除

  ```c#
  ArrayList arrayList = new ArrayList();
  //将数据新增到集合结尾处
  arrayList.Add("abc");
  arrayList.Add(123);
  //修改指定索引处的数据
  arrayList[2] = 345;
  //移除指定索引处的数据
  arrayList.RemoveAt(0);
  //移除内容为123的数据
  arrayList.Remove(123);
  //再指定索引处插入数据
  arrayList.Insert(0, "hello world");
  ```



###### List集合的声明

* *List* 集合与 *ArrayList* 由于都继承了相同的**接口**，故使用与 *ArrayList* 相似
* 在声明 *List* 集合时，需要同时为其声明 *List* 集合内数据的**对象类型**

```
示例：List<int>intList = new List<int>()
```

所谓 **接口** 目前可以简单理解成 **限制和规定** 类型行为即 **类型方法** 的一种手段

```c#
List<int> list = new List<int>();
//将数据新增到集合结尾处
list.Add(123);
//对象初始化器赋值
List<int> intList = new List<int>{
	1,2,3
};
//修改指定索引处的数值
list[2] = 345;
//移除指定索引处的数据
list.RemoveAt(0);
//移除内容为123的数据
list.Remove(123);
//在指定索引处插入数据
list.Insert(0, 6688);
```

```c#
//以下示例说明可以用自己定义的类型去限定List接收的数据类型
//方法一：
List<Person> people = new List<Person>();
Person person1 = new Person
{
	Age = 18,
	Height = 178,
	Name = "张三"
};
people.Add(person1);
people.Remove(person1);

//方法二：
List<Person> people = new List<Person>();
people.Add(new Person{
    Age = 20,
	Height = 173,
	Name = "李四"
});
Person person3 = people[0];
people.RemoveAt(0);
```

List泛型的好处指通过允许指定 **泛型类或方法** 操作的 **特定类型** ，减少了类型 **强制转换** 的需要和运行时错误的可能性，泛型提供了类型安全，但没有增加开销。



### Dictionary声明

* 在声明 *Dictionary* 字典时，需要同时为其声明 *Dictionary* 字典内 **键** 与 **值** 的类型。
* 示例： Dictionary<int, string> dictionary = new Dictionary<int,string>()
* **键** 与 **值** 可以时任何类型，但是 **键** 必须在设置时是 **唯一** 的，而 **值** 可以不唯一，就好比每个学生的学号必须是唯一的，而所有的成绩可以不唯一。

```C#
Dictionary<int, string> dictionary = new Dictionary<int, string>();
//两种赋值方式
//方法一：ADD方法赋值
dictionary.Add(1, "98分");
dictionary.Add(2, "92分");
dictionary.Add(3, "89分");
dictionary.Add(1, "91分");  //系统会报错
//方法二：索引器赋值
dictionary[1] = "88分";  // 系统不会报错
dictionary[4] = "88分";
//方法三：对象初始化器
Dictionary<string, string> dictionary2 = new Dictionary<string, string>(){
	{ "A", "aa"},
	{ "B", "bb"},
	{ "c", "cc"},
};
string value = dictionary[1]; //通过键获取值
bool b = dictionary.Remove(1); //b为true
```

**注意：**dictionary[1] 方式即可以附新值可以修改原来已经有的值，类似于数组索引器的使用。所以可以使用之前已使用过的键。但是Add方法不可以添加已有的键的值。

```c#
//获取键为1的值
//方式一：索引器取值
string value = dictionary[1];
//方式二：foreach遍历取值
foreach (KeyvaluePair<int,string> item in dictionary){
	string value = item.Value;
}

//移除键为1的键值对
dictionary.Remove(1);
```

**总结**

* **键** 与 **值** 可以是任何类型，但是 **键** 必须在设置时是 **唯一** 的，而 **值** 可以 **不唯一**
* 使用 Add() 方法添加键值对，不可添加已有的键名
* 索引模式可以 **新赋值** 也可以 **修改** 已有的键值。



### foreach的使用

##### foreach操作数组

```C#
int[] ints = {1, 2, 3, 4, 5, 6};
foreach(int item in ints)
{
	//每次循环，其item都是整型数组中的一个元素
}
```



##### foreach操作集合

```C#
List<int> intList = new List<int>(){1, 2, 3, 4, 5, 6};
foreach(int item in ints)
{
	//每次循环，其item都是List集合中的一个元素
}
```



##### foreach操作字典

```
Dictionary<string, string> dictionary = new Dictionary<string, string>(){
	{"A","aa"},
	{"B","bb"},
	{"C","cc"},
};
foreach(KeyValuepair<string, string> item in dictionary)
{
	string key = item.Key;
	string value = item.Value;
}
```



```C#
//综合一下
Person person = new Person();
List<Person> personList = person.GetUserList();
foreach(Person item in personList){
    MessageBox.Show(item.Name + "的年龄是：" + item.Age);
}

public List<Person> GetUserList()
{
    List<Person> personList = new List<Person>();
    personList.Add(new Person{
        Age = 1,
        Name = "A"
    });
    personList.Add(new Person{
        Age = 2,
        Name = "B"
    });
    personList.Add(new Person{
        Age = 3,
        Name = "C"
    });
    personList.Add(new Person{
        Age = 4,
        Name = "D"
    });
    return personList;
}
```

